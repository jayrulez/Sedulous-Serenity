namespace Sedulous.Renderer;

using System;

/// Embedded 8x8 bitmap font for debug text rendering.
/// Covers ASCII characters 32-127 (printable ASCII).
/// Each character is 8 pixels wide and 8 pixels tall.
/// Data is stored as 8 bytes per character (one byte per row, MSB left).
static class DebugFont
{
	public const int32 CharWidth = 8;
	public const int32 CharHeight = 8;
	public const int32 FirstChar = 32;   // Space
	public const int32 LastChar = 126;   // Tilde
	public const int32 CharCount = LastChar - FirstChar + 1;  // 95 characters
	public const int32 CharsPerRow = 16;
	public const int32 TextureWidth = CharsPerRow * CharWidth;   // 128
	public const int32 TextureHeight = ((CharCount + CharsPerRow - 1) / CharsPerRow) * CharHeight;  // 48 (6 rows)

	/// Font bitmap data - 8 bytes per character (one byte per row).
	/// Based on classic 8x8 bitmap font.
	public static uint8[CharCount * 8] FontData = .(
		// Space (32)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// ! (33)
		0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
		// " (34)
		0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
		// # (35)
		0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
		// $ (36)
		0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
		// % (37)
		0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
		// & (38)
		0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
		// ' (39)
		0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		// ( (40)
		0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
		// ) (41)
		0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
		// * (42)
		0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
		// + (43)
		0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
		// , (44)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
		// - (45)
		0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
		// . (46)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
		// / (47)
		0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
		// 0 (48)
		0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00,
		// 1 (49)
		0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
		// 2 (50)
		0x7C, 0xC6, 0x06, 0x1C, 0x70, 0xC6, 0xFE, 0x00,
		// 3 (51)
		0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
		// 4 (52)
		0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00,
		// 5 (53)
		0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
		// 6 (54)
		0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
		// 7 (55)
		0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
		// 8 (56)
		0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
		// 9 (57)
		0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
		// : (58)
		0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
		// ; (59)
		0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
		// < (60)
		0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00,
		// = (61)
		0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00,
		// > (62)
		0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
		// ? (63)
		0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
		// @ (64)
		0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x7C, 0x00,
		// A (65)
		0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
		// B (66)
		0xFC, 0xC6, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0x00,
		// C (67)
		0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00,
		// D (68)
		0xF8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0xF8, 0x00,
		// E (69)
		0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xFE, 0x00,
		// F (70)
		0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
		// G (71)
		0x7C, 0xC6, 0xC0, 0xCE, 0xC6, 0xC6, 0x7E, 0x00,
		// H (72)
		0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
		// I (73)
		0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
		// J (74)
		0x1E, 0x06, 0x06, 0x06, 0xC6, 0xC6, 0x7C, 0x00,
		// K (75)
		0xC6, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0xC6, 0x00,
		// L (76)
		0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00,
		// M (77)
		0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00,
		// N (78)
		0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
		// O (79)
		0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
		// P (80)
		0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
		// Q (81)
		0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
		// R (82)
		0xFC, 0xC6, 0xC6, 0xFC, 0xD8, 0xCC, 0xC6, 0x00,
		// S (83)
		0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00,
		// T (84)
		0xFE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
		// U (85)
		0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
		// V (86)
		0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
		// W (87)
		0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
		// X (88)
		0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
		// Y (89)
		0xC6, 0xC6, 0x6C, 0x38, 0x18, 0x18, 0x18, 0x00,
		// Z (90)
		0xFE, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFE, 0x00,
		// [ (91)
		0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,
		// \ (92)
		0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
		// ] (93)
		0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,
		// ^ (94)
		0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
		// _ (95)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
		// ` (96)
		0x18, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
		// a (97)
		0x00, 0x00, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
		// b (98)
		0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xFC, 0x00,
		// c (99)
		0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00,
		// d (100)
		0x06, 0x06, 0x7E, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
		// e (101)
		0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
		// f (102)
		0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00,
		// g (103)
		0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
		// h (104)
		0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
		// i (105)
		0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
		// j (106)
		0x06, 0x00, 0x06, 0x06, 0x06, 0xC6, 0xC6, 0x7C,
		// k (107)
		0xC0, 0xC0, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0x00,
		// l (108)
		0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
		// m (109)
		0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
		// n (110)
		0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
		// o (111)
		0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
		// p (112)
		0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0,
		// q (113)
		0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x06,
		// r (114)
		0x00, 0x00, 0xDC, 0xE6, 0xC0, 0xC0, 0xC0, 0x00,
		// s (115)
		0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00,
		// t (116)
		0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,
		// u (117)
		0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
		// v (118)
		0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
		// w (119)
		0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
		// x (120)
		0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
		// y (121)
		0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
		// z (122)
		0x00, 0x00, 0xFE, 0x0C, 0x38, 0x60, 0xFE, 0x00,
		// { (123)
		0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,
		// | (124)
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
		// } (125)
		0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,
		// ~ (126)
		0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	);

	/// Generates the font texture data as a single-channel grayscale image.
	/// Returns a texture buffer of size TextureWidth * TextureHeight bytes.
	public static uint8[] GenerateTextureData()
	{
		uint8[] data = new uint8[TextureWidth * TextureHeight];

		for (int charIdx = 0; charIdx < CharCount; charIdx++)
		{
			let charRow = charIdx / CharsPerRow;
			let charCol = charIdx % CharsPerRow;
			let baseX = charCol * CharWidth;
			let baseY = charRow * CharHeight;

			for (int row = 0; row < CharHeight; row++)
			{
				let rowByte = FontData[charIdx * 8 + row];
				for (int col = 0; col < CharWidth; col++)
				{
					let bit = (rowByte >> (7 - col)) & 1;
					let pixelX = baseX + col;
					let pixelY = baseY + row;
					data[pixelY * TextureWidth + pixelX] = (bit != 0) ? 255 : 0;
				}
			}
		}

		return data;
	}

	/// Gets the UV coordinates for a character.
	/// Returns false if character is out of range.
	public static bool GetCharUV(char32 c, out float u0, out float v0, out float u1, out float v1)
	{
		u0 = 0; v0 = 0; u1 = 0; v1 = 0;

		let charCode = (int32)c;
		if (charCode < FirstChar || charCode > LastChar)
			return false;

		let charIdx = charCode - FirstChar;
		let charRow = charIdx / CharsPerRow;
		let charCol = charIdx % CharsPerRow;

		u0 = (float)(charCol * CharWidth) / (float)TextureWidth;
		v0 = (float)(charRow * CharHeight) / (float)TextureHeight;
		u1 = (float)((charCol + 1) * CharWidth) / (float)TextureWidth;
		v1 = (float)((charRow + 1) * CharHeight) / (float)TextureHeight;

		return true;
	}
}
